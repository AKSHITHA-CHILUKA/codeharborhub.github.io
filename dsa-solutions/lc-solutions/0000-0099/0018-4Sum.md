---
id: 4Sum
title: 4Sum (LeetCode)
sidebar_label: 0018-4Sum.md
tags:
    - Arrays
    - Hashing
    - Two Pointers
description: Given an array `nums` of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a, b, c, and d are distinct`
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

---

## Problem Description

| Problem Statement                                                                                           
| Solution Link                                                                                                                               
| LeetCode Profile                                   
|
| :----------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------- |
| [4Sum](https://leetcode.com/problems/4sum/description/)                                         
| [4Sum Solution on LeetCode](https://leetcode.com/submissions/detail/1282735174/) 
| [Saini_Nikita]https://leetcode.com/submissions/detail/1282735174/ |

### Problem Description

## Problem Statement:
Write a function that finds all unique quadruplets in the array which gives the sum of the target.

### Examples

#### Example 1

- **Input:** `nums = [1,0,-1,0,-2,2]`
              `target = 0`
- **Output:** `[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`

#### Example 2

- **Input:** `nums = [2,2,2,2,2]`
             `target = 8`
- **Output:** `[2,2,2,2]`

## Constraints
- `1 <= nums.length <= 200`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`

## Approach
1. **Sorting**: Start by sorting the array `nums`. This helps in avoiding duplicates and simplifies the two-pointer approach.
2. **Nested Loops**: Use two nested loops to fix the first two elements of the quadruplet (`i` and `j`). The outer loop runs from `0` to `n-3` and the inner loop runs from `i+1` to `n-2`.
3. **Two-Pointer Technique**: For the remaining two elements of the quadruplet, use two pointers (`left` and `right`). Initialize `left` to `j+1` and `right` to `n-1`.
4. **Avoiding Duplicates**: Skip duplicate elements in both the outer and inner loops to ensure the uniqueness of quadruplets.
5. **Finding Quadruplets**: Check if the sum of the current quadruplet equals the target. If it does, add it to the result list. Then, move the `left` and `right` pointers inward, skipping duplicates.
6. **Adjusting Pointers**: If the sum is less than the target, move the `left` pointer to the right. If the sum is greater than the target, move the `right` pointer to the left.
7. **Returning the Result**: Once all quadruplets are found, return the result list.

### Solution Code

#### Python

```python
class Solution:
    def fourSum(self, nums, target):
        nums.sort()
        n = len(nums)
        result = []

        for i in range(n - 3):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, n - 2):
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue

                left = j + 1
                right = n - 1

                while left < right:
                    sum_ = nums[i] + nums[j] + nums[left] + nums[right]

                    if sum_ == target:
                        result.append([nums[i], nums[j], nums[left], nums[right]])

                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1

                        left += 1
                        right -= 1
                    elif sum_ < target:
                        left += 1
                    else:
                        right -= 1

        return result
```

#### Java

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 4) {
            return result;
        }

        Arrays.sort(nums);
        int n = nums.length;

        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }

                int left = j + 1;
                int right = n - 1;

                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                    if (sum == target) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }

                        left++;
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }

        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        int[] nums1 = {1, 0, -1, 0, -2, 2};
        int target1 = 0;
        List<List<Integer>> result1 = solution.fourSum(nums1, target1);
        System.out.println(result1);

        int[] nums2 = {2, 2, 2, 2, 2};
        int target2 = 8;
        List<List<Integer>> result2 = solution.fourSum(nums2, target2);
        System.out.println(result2);
    }
}
```

#### CPP:
```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> fourSum(std::vector<int>& nums, int target) {
        std::vector<std::vector<int>> result;
        if (nums.size() < 4) return result;

        std::sort(nums.begin(), nums.end());
        int n = nums.size();

        for (int i = 0; i < n - 3; ++i) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n - 2; ++j) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1;
                int right = n - 1;

                while (left < right) {
                    long sum = (long)nums[i] + nums[j] + nums[left] + nums[right];

                    if (sum == target) {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});

                        while (left < right && nums[left] == nums[left + 1]) ++left;
                        while (left < right && nums[right] == nums[right - 1]) --right;

                        ++left;
                        --right;
                    } else if (sum < target) {
                        ++left;
                    } else {
                        --right;
                    }
                }
            }
        }

        return result;
    }
};
```

#### JavaScript
```js
  @param {number[]} nums
  @param {number} target
  @return {number[][]}
 
var fourSum = function(nums, target) {
    let result = [];
    if (nums.length < 4) return result;

    nums.sort((a, b) => a - b);

    for (let i = 0; i < nums.length - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        for (let j = i + 1; j < nums.length - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;

            let left = j + 1;
            let right = nums.length - 1;

            while (left < right) {
                let sum = nums[i] + nums[j] + nums[left] + nums[right];

                if (sum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    while (left < right && nums[left] === nums[left + 1]) left++;
                    while (left < right && nums[right] === nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return result;
};

// Example Usage
console.log(fourSum([1,0,-1,0,-2,2], 0));
console.log(fourSum([2,2,2,2,2], 8));
```

## Step-by-Step Algorithm

1. **Input Validation**: Check if the array is null or has fewer than 4 elements. If so, return an empty list.
2. **Sort the Array**: Sort the input array `nums`.
3. **Outer Loop**: Iterate over the array with index `i` from `0` to `n-4`.
   - Skip duplicate elements by checking if `nums[i] == nums[i-1]` (for `i > 0`).
4. **Inner Loop**: For each `i`, iterate with index `j` from `i+1` to `n-3`.
   - Skip duplicate elements by checking if `nums[j] == nums[j-1]` (for `j > i+1`).
5. **Two Pointers**: Initialize two pointers `left = j+1` and `right = n-1`.
6. **Finding Quadruplets**:
   - While `left < right`:
     - Calculate the sum of the quadruplet: `sum = nums[i] + nums[j] + nums[left] + nums[right]`.
     - If the sum equals the target:
       - Add `[nums[i], nums[j], nums[left], nums[right]]` to the result.
       - Move `left` to the right, skipping duplicates.
       - Move `right` to the left, skipping duplicates.
     - If the sum is less than the target, move `left` to the right.
     - If the sum is greater than the target, move `right` to the left.
7. **Return the Result**: After processing all elements, return the list of quadruplets.